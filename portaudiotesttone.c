/*
 * This is the source code for TestTone, which is based on PortAudio V18 (http://www.portaudio.com).
 *
 * TestTone is part of MATAA. MATAA is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * MATAA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with MATAA; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * 
 * Copyright (C) 2006, 2007, 2008 Matthias S. Brennwald.
 * Contact: info@audioroot.net
 * Further information: http://www.audioroot.net/MATAA.html
 */


/* 
TestTone is a console program that reads a test tone from a text file. This tone is then played through the default audio output device, and simultaneously recorded through the default audio input device. Alternatively, if no input file is given, then a default signal is generated.

TestTone makes use of PortAudio to communicate with the audio device (see http://www.portaudio.com). This should allow TestTone to be compiled on several platforms.

TestTone is invoked from the console as follows:
console> TestTone testSignal.in > testSignal.out
(this reads the text file testSignal.in which contains the samples of the input signal (mono, one sample per line, max. value = 1, min. value = -1). The result is written to STDIO, here it is piped into the file 'testSignal.out'.

console> TestTone  > testSignal.out
(As above, but without specifying an input signal. A default signal is generated by TestTone)
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "portaudio.h"

#define PI		(3.141592653589793)
#define PA_SAMPLE_TYPE  paFloat32

typedef float		SAMPLE;

typedef struct
{
    unsigned long	numFrames;
    unsigned long	processedFrames;
    unsigned int	numInputDeviceChannels;
    unsigned int	numOutputDeviceChannels;
    float		samplingRate;
    SAMPLE		*inputSamples;
    SAMPLE		*outputSamples;
}
paTestData, *paTestDataPtr;

/* This routine will be called by the PortAudio engine when audio is needed.
** It may be called at interrupt level on some machines so don't do anything
** that could mess up the system like calling malloc() or free().
*/
static int RecordAndPlayCallback(
                            const void *inputBuffer,
                            void *outputBuffer,
                            unsigned long framesPerBuffer,
                            const PaStreamCallbackTimeInfo* outTime,
							PaStreamCallbackFlags statusFlags,
                            void *userData )
{
    unsigned long iF,iFmax,remainingFrames,iC;
    paTestData* data;
    int finished;
    
/* Cast data passed through stream to our structure. */
    data = (paTestDataPtr)userData;
    
/* Handle sound output buffer */
    SAMPLE *out = (SAMPLE*)outputBuffer;
    //(void) outTime; /* Prevent unused variable warnings. */
    //(void) inputBuffer;
    remainingFrames = data->numFrames - data->processedFrames;
    if (remainingFrames > framesPerBuffer)
    {
        iFmax=framesPerBuffer;
        finished=0;
    }
    else
    { /* last buffer... */
        iFmax=remainingFrames;
        finished=1;
    }
		
    for( iF=0; iF<iFmax; iF++ )
    {
        for( iC=0; iC < data->numOutputDeviceChannels; iC++ ) {
			*out++ = data->outputSamples[(iF+data->processedFrames)*data->numOutputDeviceChannels+iC];
		}
    }

/* Handle sound input buffer */
    SAMPLE *in = (SAMPLE*)inputBuffer;
    for( iF=0; iF<iFmax; iF++ )
    {
        for( iC=0; iC<data->numInputDeviceChannels; iC++ ) data->inputSamples[(iF+data->processedFrames)*data->numInputDeviceChannels+iC]=*in++;
    }
    
/* Prepare for next callback-cycle: */    
    data->processedFrames += iFmax;

return finished;
}


/*******************************************************************/
int main(int argc, char *argv[]);
int main(int argc, char *argv[])
{
    PaStream		*stream;
    PaError			err;
    paTestData		data;
    unsigned long	iFrame,iChannel;
    unsigned long	numBytes;
    SAMPLE			*testSignal;
	unsigned int	numChanTestSignal = 0;    // number of channels in the test signal generated or read from disk. This should be less or equal than the number of output channels supported by the sound output device

    /* check for proper input */
	
	// argv[1]: sample rate in Hz
	// argv[2]: input file name (optional)
	
    argc -=1; /* first argument is call to TestTone itself */
	
    if (argc == 0) // print usage information
	{
        printf("Not enough input arguments.\n\n");
		printf("Usage:\n");
		printf("'TestTone 44100' plays a 1-kHz sine with a sampling rate of 44.1 kHz and records the response signal.\n");
		printf("'TestTone 44100 myTestSignal' plays the test-signal samples in the ASCII-file 'myTestSignal' at a sampling rate of 44.1 kHz and records the response signal.\n\n");
		printf("The file format of the input file is as follows:\n");
		printf(" - data is given using comma separated values (CSV).");
		printf(" - each column corresponds to one data channel.");
		printf(" - each line corresponds to one frame (one frame corresponds to all samples from the same time step.\n");
		printf(" - data channels are separated by commas.\n");
		printf(" - no headers or extra information are allowed.\n");
		printf("\n");
		printf("If the input file contains less data channels than supported by the sound output device, the last channel in the input file will be copied to the remaining channels of the output device.\n\n");
		printf("Some input file examples:\n\n");
 		printf(" 1. square-wave signal with one data channel\n\n");
 		printf("    -1\n"); 
 		printf("    -1\n");
 		printf("    -1\n"); 
 		printf("     1\n");
 		printf("     1\n"); 
 		printf("     1\n");
 		printf("     1\n");
 		printf("    -1\n");
 		printf("     .\n");
 		printf("     .\n");
 		printf("     .\n\n");
 		printf(" 2. Two channel signal (channel-1: square-wave, channel-2: noise):\n\n");
 		printf("    -1 ,  0.7831\n"); 
 		printf("    -1 , -0.2254\n");
 		printf("    -1 ,  0.1698\n"); 
 		printf("     1 , -0.4368\n");
 		printf("     1 ,  0.0282\n"); 
 		printf("     1 , -0.7142\n");
 		printf("     1 , -0.5516\n");
 		printf("    -1 ,  0.7311\n");
 		printf("     .    .\n");
 		printf("     .    .\n");
 		printf("     .    .\n\n");
		printf("TestTone is part of MATAA. MATAA is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\n");
		printf("MATAA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\n");
		printf("You should have received a copy of the GNU General Public License along with MATAA; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n");
		printf("Copyright (C) 2006, 2007, 2008 Matthias S. Brennwald.\nContact: info@audioroot.net\nFurther information: http://www.audioroot.net/mataa.html\n");
		exit(1);
	}

	// initialize PortAudio:
    err = Pa_Initialize();
    if( err != paNoError ) goto pa_error;
	
	// get audio devices info:
	int inputDevice = Pa_GetDefaultInputDevice();
	if (inputDevice < 0)
	{
        printf( "ERROR: Pa_GetDefaultInputDevice returned %i\n", inputDevice );
        err = inputDevice;
        goto pa_error;
    }
	const   PaDeviceInfo *inputInfo;
	inputInfo = Pa_GetDeviceInfo( inputDevice );
	
	int outputDevice = Pa_GetDefaultOutputDevice();
	if (outputDevice < 0)
	{
        printf( "ERROR: Pa_GetDefaultOutputDevice returned %i\n", outputDevice );
        err = outputDevice;
        goto pa_error;
    }
	const   PaDeviceInfo *outputInfo;
	outputInfo = Pa_GetDeviceInfo( outputDevice );

	// Prepare data:
    data.processedFrames = 0;
    data.numInputDeviceChannels = inputInfo->maxInputChannels;
    data.numOutputDeviceChannels = outputInfo->maxOutputChannels;
	data.samplingRate = atof(argv[1]);
	
    if (argc == 1) { // no input file is given, use some default signal instead
        printf("%% No input file given! Using default signal instead: 1 kHz sine, 1 sec duration\n");
		numChanTestSignal = 1;
        data.numFrames=data.samplingRate; // determines signal duration
        float f=1000.0; // frequency of test tone 
        testSignal = (SAMPLE*)malloc(numChanTestSignal*data.numFrames*sizeof(SAMPLE));
		if (!testSignal) {
			printf("ERROR: could not allocate memory for test data\n");
			goto error;
		}
		if (data.samplingRate <= 2*f) {
			printf("%% *** Warning: Nyquist frequency too low because sampling rate is too low!\n");
		}
        for (iFrame=0; iFrame<data.numFrames; iFrame++) testSignal[iFrame]=sin((float)iFrame/data.samplingRate*f*2.0*PI);
    }

    if (argc == 2) // read the input file specified in argv[2]
    {
        char	s[1000];
		char	*u = NULL;
		char	*delim;
        FILE	*inFile;
        
        printf("%% Input file: %s\n", argv[2]);
        
    	inFile=fopen(argv[2],"r");
        if (!inFile) {
			printf("ERROR: could not open the input file.");
			goto error;
		}
		
        // get number of input signal frames:
        data.numFrames=0;
        while (fgets(s,1000,inFile)!=NULL) {
            data.numFrames +=1;
        }
		
		// get number of data channels in input file:
		fseek(inFile,0,SEEK_SET); // go back to the beginning of the file
		delim = ",";
		fgets(s,1000,inFile); // read first line of the input file
		// find and count delimiters:
		u = strtok(s,delim);
		while( u != NULL) {
			numChanTestSignal++;
			// printf("%s\n",u);
			u = strtok(NULL,delim);
		}
		printf("%% Number of data channels in input file = %d\n", numChanTestSignal);

		if ( numChanTestSignal > data.numOutputDeviceChannels ) {
			printf("ERROR: the input file has more channels (%d) than supported by the sound output device (%d).\n",numChanTestSignal,data.numOutputDeviceChannels);
			goto error;
		}

		// allocate memory to hold the data read from the input file:
        testSignal = (SAMPLE*)malloc(numChanTestSignal*data.numFrames*sizeof(SAMPLE));
		if (!testSignal) {
			printf("ERROR: could not allocate memory for test data\n");
			goto error;
		}
        fseek(inFile,0,SEEK_SET); // go back to the beginning of the file
		iFrame = 0;
				
        for (iFrame = 0; iFrame < data.numFrames; iFrame++) {
			iChannel = 0;
			if (fgets(s,1000,inFile) == NULL) {
				printf("ERROR: could not read input file on line %d.\n",iFrame);
				goto error;
			}
			u = strtok(s,delim);
			// printf(u);
			while (iChannel < numChanTestSignal) {
				if (!u) {
					printf("ERROR: could not read input file on line %d.\n",iFrame);
					goto error;
				}
				// printf("%s",u);
				testSignal[ numChanTestSignal*iFrame + iChannel ]=atof(u);
				iChannel++;
				u = strtok(NULL,delim);
			}
        }
        fclose(inFile);
    }
	
	// allocate memory for output data:
    numBytes = data.numFrames * data.numOutputDeviceChannels * sizeof(SAMPLE);
    data.outputSamples= (SAMPLE *) malloc( numBytes );
    if( data.outputSamples == NULL )
    {
        printf("ERROR: could not allocate output frames buffer.");
        exit(1);
    }
    
	// move the testSignal to data.outputSamples:
	unsigned int dummy;
	for ( dummy = 0; dummy < data.numOutputDeviceChannels; dummy++ ) {
		if (dummy < numChanTestSignal) {
			iChannel = dummy;
		}
		else {
			iChannel = numChanTestSignal-1;
		}
		for( iFrame = 0; iFrame < data.numFrames; iFrame++ ) {
			data.outputSamples[data.numOutputDeviceChannels*iFrame+dummy] = testSignal[numChanTestSignal*iFrame+iChannel];
		}
	}
	
    free(testSignal);

    data.inputSamples= (SAMPLE *) malloc( numBytes );
    if( data.inputSamples == NULL )
    {
        printf("Could not allocate output frames buffer");
        exit(1);
    }

    for( iFrame=0; iFrame<data.numFrames; iFrame++ ) // initialize input frames:
    {
        for( iChannel=0; iChannel < data.numInputDeviceChannels; iChannel++ ) {
			data.inputSamples[iFrame*data.numInputDeviceChannels+iChannel] = 0;
		}
    }
	
	// Record and play audio data:	
    err = Pa_OpenDefaultStream( &stream,
                                data.numInputDeviceChannels,          // number of input channels
                                data.numOutputDeviceChannels,         // number of input channels
								PA_SAMPLE_TYPE,					// sample type
								data.samplingRate,				// sampling rate
                                256,							// frames per buffer (use something in the 128-1024 range, or use paFramesPerBufferUnspecified to let portaudio decide)
								RecordAndPlayCallback,			// the callback function
                                &data );						// pointer to the audio data
	if( err != paNoError ) 
	{
		printf( "ERROR: Pa_OpenDefaultStream returned %i\n", err );
        goto pa_error;
	}
									
    err = Pa_StartStream( stream );
	if( err != paNoError ) 
	{
		printf( "ERROR: Pa_StartStream returned %i\n", err );
        goto pa_error;
	}

    while( Pa_IsStreamActive( stream ) )
    {
        Pa_Sleep(1); // sleep while audio I/O
    }
    err = Pa_CloseStream( stream );
	if( err != paNoError ) 
	{
		printf( "ERROR: Pa_CloseStream returned %i\n", err );
        goto pa_error;
	}

    Pa_Terminate();

	// print header:
    printf("%% Number of frames = %d\n", data.numFrames);
    printf("%% Number of sound output channels = %d\n", data.numOutputDeviceChannels);
    printf("%% Number of sound input channels = %d\n", data.numInputDeviceChannels);
    printf("%% Sampling rate = %f Hz\n", data.samplingRate);
	printf("%%\n");
	printf("%% Recorded data:\n"),
    printf("%% time (s)\t");
    for( iChannel=0; iChannel < data.numInputDeviceChannels;)
    {
        iChannel++;
        printf("channel-%d ",iChannel);
    }
    printf("\n");
    
	// print recorded data:
    float frameTime;
    for( iFrame=0; iFrame<data.numFrames; iFrame++ )
    {
	frameTime = (float)iFrame / data.samplingRate;
        printf("%E",frameTime); // print frame sampling time
        for( iChannel = 0; iChannel < data.numInputDeviceChannels; iChannel++ )
        {
            printf("\t");
            printf("%E",data.inputSamples[iFrame*data.numInputDeviceChannels+iChannel]);
        }
        printf("\n");
    }
		
	// clean up:
    free(data.inputSamples);
    free(data.outputSamples);
					
	// exit:
    return 0;
	
pa_error:
    fprintf( stderr, "An error occured while using the portaudio stream\n" );
    fprintf( stderr, "Error number: %d\n", err );
    fprintf( stderr, "Error message: %s\n", Pa_GetErrorText( err ) );
	fprintf( stderr, "Last error from host API: %s\n", Pa_GetLastHostErrorInfo()->errorText );
	goto error;

error:
    Pa_Terminate();
	return -1;
	
}
